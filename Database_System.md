# 数据库系统复习笔记

## 非关系型数据库和关系型数据库
- 非关系型数据库应对需求变动较灵活，无Schema，增加字段仅需要非常少的改动，支持非结构化和半结构化的数据。
- 非关系型数据库文档模型较自然，与关系型数据库中表结构不同，非关系型数据库与面向对象的表达方式更相似。
- 关系型数据库对事务的支持较完善，通过事务保证了数据的一致性。
- 关系型数据库支持Join等复杂查询。

## Oracle数据库和MySQL
- Oracle对事务的支持比较完善；MySQL在InnoDB引擎下才支持事务。
- Oracle对并发性的支持更好，通常以行级锁为主，并且不依赖索引；MySQL通常以表级锁为主，InnoDB引擎下支持行级锁，但依赖索引。
- Oracle通过将提交的SQL写入在线联机日志文件中，并保存到磁盘上来保证数据的持久性；MySQL更新或重启会出现数据丢失。

## 事务
- 事务（Transaction）：一组SQL语句。
- 回退（Rollback）：撤销指定SQL语句的过程。
- 提交（Commit）：将未存储的SQL语句结果写入数据库表。

## ACID
- 原子性（Atomicity）：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
- 一致性（Consistency）：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
- 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的。
- 持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

## 范式
- 第一范式（1NF）：强调列的原子性，即列不能够再分成其他几列。
- 第二范式（2NF）：表必须有一个主键，没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
- 第三范式（3NF）：任何非主属性不依赖于其它非主属性。

## 存储过程
- 代码封装，保证了一定的安全性。
- 代码复用。
- 预先编译，具有很高的性能。

## 并发事务带来的问题
1. 脏读（Dirty Read）：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
1. 不可重复读（Unrepeatable Read）：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
1. 幻读（Phantom Read）：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
1. 丢失修改（Lost to Modify）：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

## 隔离级别
1. 读未提交（Read Uncommitted）：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
1. 读已提交（Read Committed）：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
1. 可重复读（Repeated Read）：在同一个事务内的查询都与事务开始时刻是一致的，即对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
1. 串行化（Serializable）：高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

## 引擎
- MyISAM：适合读密集的情况，性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。
- InnoDB：支持行级锁，事务，外部键，存储点等高级数据库功能，具有回滚和崩溃修复能力的事务安全型表。

## 锁

### 共享锁（Shared Lock、S锁、读锁）与独享锁（Exclusive Lock、X锁、写锁）
- 一个事务对数据对象A加了X锁，可以对A进行读取和更新。加锁期间其它事务不能对A加任何锁。
- 一个事务对数据对象A加了S锁，可以对A进行读取操作，但是不能进行更新操作。加锁期间其它事务能对A加S锁，但是不能加X锁。
- 避免写写、写读、读写冲突，参考三级封锁协议。

### 意向锁（Intention Lock）
- 在存在行级锁和表级锁的情况下，事务T想要对表A加X锁，就需要先检测是否有其它事务对表A或者表A中的任意一行加了锁，那么就需要对表A的每一行都检测一次，这是非常耗时的。
- 意向锁在原来的X/S锁之上引入了IX/IS，IX/IS都是表锁，用来表示一个事务想要在表中的某个数据行上加X锁或S锁。
- 一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或者更强的锁。
- 一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁。

### 两段锁协议（Two-Phase Locking、2PL）
- 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁。
- 在释放一个封锁之后，事务不再申请和获得其它任何封锁。
- 事务的执行分为两个阶段：第一阶段是获得封锁的阶段，称为扩展阶段。第二阶段是释放封锁的阶段，称为收缩阶段。

### 粒度锁
- 尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

#### 表级锁
- 对当前操作的整张表加锁。

#### 行级锁
- 单个行记录上的锁。

#### 间隙锁（Gap Lock）
- 锁定一个范围，不包括记录本身。
- 当我们用范围条件检索数据而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合范围条件的已有数据记录的索引项加锁。间隙锁只会在Repeatable read隔离级别下使用（为了防止幻读）。

#### Next-key Lock
- Record + Gap：锁定一个范围，包含记录本身。

## 多版本并发控制（Multi-Version Concurrency Control、MVCC）
- 系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号：事务开始时的系统版本号。
- 每行记录后面都保存着两个隐藏的列，用来存储两个版本号：创建版本号（指示创建一个数据行的快照时的系统版本号）、删除版本号（如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了）。
- 通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本。

## 日志

### 重做日志（Redo Log）
- 确保事务的持久性。若在发生故障时有脏页未写入磁盘，在重启MySQL服务时根据Redo Log进行重做，从而达到事务的持久性这一特性。
- 事务开始后就产生Redo Log；在事务的执行过程中，写入Redo Log文件中。
- 当对应事务的脏页写入到磁盘之后，Redo Log占用的空间就可以重用或被覆盖。

### 回滚日志（Undo Log）
- 保存了事务发生之前的数据的一个版本，可以用于回滚

## 分布式数据库

### CAP
1. 一致性（Consistency）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。
1. 可用性（Availability）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。
1. 分区容忍性（Partition tolerance）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

### 表优化
- 读写分离：主库负责写，从库负责读。
- 垂直分区：数据表列的拆分，把一张列比较多的表拆分为多张表。在查询时减少读取的Block数，减少I/O次数，简化表的结构，易于维护。但主键会出现冗余，需要管理冗余列，事务变得更加复杂。
- 水平分区：保持数据表结构不变，通过某种策略存储数据分片。解决了单一表数据过大的问题。但分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。

### 分库分表

### 主从复制

### 负载均衡
