# 并发

## 基础

### 同步与异步
- 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。
- 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。

### 阻塞与非阻塞
- 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。
- 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

## 锁

### 悲观锁和乐观锁
- 悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
- 乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只在更新数据的时候去判断之前有没有别的线程更新了这个数据（例如CAS算法）。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或自动重试）。
- 悲观锁（例）：synchronized关键字和Lock的实现类
- 乐观锁（例）：Atomic类中的递增
- 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
- 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

### 公平锁和非公平锁
- 公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。
- 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待，但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁。
- 阻塞线程的唤醒具有一定的开销，如果在尝试唤醒某个阻塞线程时，正好有一个线程申请锁：非公平锁将允许这个线程插队来减少唤起线程的开销；而公平锁将使其阻塞。
- 公平锁：等待锁的线程不会饿死，但整体吞吐效率较低。
- 非公平锁：减少唤起线程的开销，整体的吞吐效率高，但线程可能会饿死。

### 可重入锁和不可重入锁
- 可重入锁：同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。
- 不可重入锁：同一个线程不能再次获得之前已经获得的锁，容易产生死锁。

### 共享锁和独享锁（排他锁、专有锁、互斥锁）
- 共享锁：该锁可被多个线程所持有。获得共享锁的线程只能读数据，不能修改数据。
- 独享锁：该锁一次只能被一个线程所持有。获得独享锁的线程即能读数据又能修改数据。

### 自旋锁和非自旋锁（阻塞锁）
- 自旋锁：采用让当前线程不停地在循环体内执行实现，当循环的条件被其它线程改变时才能进入临界区。
- 阻塞锁：让线程进入阻塞状态进行等待，当获得相应的信号（唤醒）时，才可以进入准备就绪状态，再通过竞争，进入运行状态。
- 由于自旋锁只是让当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。
- 阻塞的线程不会占用CPU时间，不会导致CPU占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。
- 如果是单核处理器，建议不要使用自旋锁。
- 如果是多核处理器并且预计线程等待锁的时间较短，短到比线程两次上下文切换时间要少的情况下，建议使用自旋锁。
- 如果是多核处理器并且预计线程等待锁的时间较长，至少比两次线程上下文切换的时间要长，建议使用阻塞锁。
- 如果加锁的代码经常被调用，但竞争情况很少发生时，应该优先考虑使用自旋锁，自旋锁的开销比较小，互斥量的开销较大。

## CAS

### CAS算法
- CAS全称Compare And Swap（比较并交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。
- CAS算法涉及到三个操作数：需要读写的内存值V，进行比较的值A，要写入的新值B。
- 当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作，在JNI里是借助于一个CPU指令完成），否则不会执行任何操作。
一般情况下，“更新”是一个不断重试的操作，但如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。
- AtomicReference类保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作，保证了对多个共享变量操作的原子性。

### ABA问题
- CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。
- ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。

## Synchronized关键字

### 锁升级
- 无锁：没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。CAS算法即为一种无锁的实现。
- 偏向锁：一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
- 轻量级锁：当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁。其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
- 重量级锁：除了拥有锁的线程以外的线程都阻塞。

### 锁优化
- 适应性自旋：通过学习自旋的次数来获取重量级锁。如果自旋成功，则下次自旋的次数会更多；如果自旋失败，则自旋的次数就会减少。
- 锁粗化：合并多个连续的加锁和解锁操作，扩展成一个范围更大的锁。
- 锁消除：删除多余的加锁操作。

## volatile关键字

