# Java并发

## 基础

### 同步与异步
- 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。
- 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。

### 阻塞与非阻塞
- 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。
- 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

### 并发与并行
- 并发：同一个时间段里，多个任务交替进行。
- 并行：单位时间内，多个任务同时进行。

### 进程与线程
- 调用一个main函数时会启动一个JVM进程，main函数所在的线程即为主线程。
- 同一个进程中的线程共享堆和方法区的资源，独享虚拟机栈、本地方法栈和程序计数器。

## 锁

### 悲观锁与乐观锁
- 悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
- 乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只在更新数据的时候去判断之前有没有别的线程更新了这个数据（例如CAS算法）。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或自动重试）。
- 悲观锁（例）：synchronized关键字和Lock的实现类
- 乐观锁（例）：Atomic类中的递增
- 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
- 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

### 公平锁与非公平锁
- 公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。
- 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待，但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁。
- 阻塞线程的唤醒具有一定的开销，如果在尝试唤醒某个阻塞线程时，正好有一个线程申请锁：非公平锁将允许这个线程插队来减少唤起线程的开销；而公平锁将使其阻塞。
- 公平锁：等待锁的线程不会饿死，但整体吞吐效率较低。
- 非公平锁：减少唤起线程的开销，整体的吞吐效率高，但线程可能会饿死。

### 可重入锁与不可重入锁
- 可重入锁：同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。
- 不可重入锁：同一个线程不能再次获得之前已经获得的锁，容易产生死锁。

### 共享锁与独享锁（排他锁、专有锁、互斥锁）
- 共享锁：该锁可被多个线程所持有。获得共享锁的线程只能读数据，不能修改数据。
- 独享锁：该锁一次只能被一个线程所持有。获得独享锁的线程即能读数据又能修改数据。

### 自旋锁与非自旋锁（阻塞锁）
- 自旋锁：采用让当前线程不停地在循环体内执行实现，当循环的条件被其它线程改变时才能进入临界区。
- 阻塞锁：让线程进入阻塞状态进行等待，当获得相应的信号（唤醒）时，才可以进入准备就绪状态，再通过竞争，进入运行状态。
- 由于自旋锁只是让当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。
- 阻塞的线程不会占用CPU时间，不会导致CPU占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。
- 如果是单核处理器，建议不要使用自旋锁。
- 如果是多核处理器并且预计线程等待锁的时间较短，短到比线程两次上下文切换时间要少的情况下，建议使用自旋锁。
- 如果是多核处理器并且预计线程等待锁的时间较长，至少比两次线程上下文切换的时间要长，建议使用阻塞锁。
- 如果加锁的代码经常被调用，但竞争情况很少发生时，应该优先考虑使用自旋锁，自旋锁的开销比较小，互斥量的开销较大。

## CAS

### CAS算法
- CAS全称Compare And Swap（比较并交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。
- CAS算法涉及到三个操作数：需要读写的内存值V，进行比较的值A，要写入的新值B。
- 当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作，在JNI里是借助于一个CPU指令完成），否则不会执行任何操作。
一般情况下，“更新”是一个不断重试的操作，但如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。
- AtomicReference类保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作，保证了对多个共享变量操作的原子性。

### ABA问题
- CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。
- ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。

## 线程死锁

### 四个必要条件
- 互斥：一个资源只能被一个线程占用。
- 不可抢占：资源不能被强行剥夺，只能由持有线程释放。
- 占有且等待：线程请求资源而阻塞，不释放持有资源。
- 循环等待：多个线程间形成头尾相接的循环等待资源关系。

### 避免死锁
- 破坏占有且等待：一次性申请所有资源。
- 破坏不可抢占：申请不到资源时释放所有已持有的资源。
- 破坏循环等待：不同的线程按同样的顺序申请资源。

## Java线程

### 生命周期
- NEW：创建后尚未启动
- RUNNABLE：可运行，正在等待CPU时间片(包括READY和RUNNING)
- WAITING：等待被显式唤醒（释放锁）
- TIMED_WAITING：系统自动唤醒（不释放锁）
- BLOCKED：等待其线程释放锁
- TERMINATED：线程结束任务或抛出异常结束

### 创建
- 通过继承Thread类创建线程
- 通过实现Runnable接口创建线程
- 通过实现Callable接口并封装FutureTask对象创建线程

### 方法
- start()：开启此线程，进入可运行的状态，之后由JVM调度执行。
- interrupt()：中断此线程。
- join()：调用线程等待此线程死亡。
- sleep()：造成当前线程进行周期性睡眠，线程不释放锁资源。
- yield()：提示调度器当前线程愿意让出当前CPU的使用权。

### 线程池
- 通过Executors.newFixedThreadPool()创建固定长度的线程池
- 通过Executors.newCachedThreadPool()创建非固定长度的缓存型线程池
- 通过Executors.newSingleThreadExecutor()创建单线程的线程池
- 通过Executors.newScheduledThreadPool()创建固定长度的延迟型线程池
- 通过ThreadPoolExecutor构造函数创建线程池，自定义工作队列，线程工厂，拒绝策略等

## Synchronized关键字

### 锁升级
- 无锁：没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。CAS算法即为一种无锁的实现。
- 偏向锁：一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
- 轻量级锁：当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁。其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
- 重量级锁：除了拥有锁的线程以外的线程都阻塞。

### 锁优化
- 适应性自旋：通过学习自旋的次数来获取重量级锁。如果自旋成功，则下次自旋的次数会更多；如果自旋失败，则自旋的次数就会减少。
- 锁粗化：合并多个连续的加锁和解锁操作，扩展成一个范围更大的锁。
- 锁消除：删除多余的加锁操作。

## volatile关键字

## ReentrantLock类

## ThreadLocal类

## 同步工具类

### CountDownLatch（闭锁）
- 闭锁可以延迟线程的进度直到其达到终止状态。
- 闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。
- 当闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动直到其它活动都完成后才继续执行。
- CountDownLatch是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。
- 闭锁是一次性对象，一旦进入最终状态，就不能被重置了。

### CyclicBarrier（栅栏）
- 栅栏能阻塞一组线程直到某个事件发生。
- 栅栏与闭锁的关键区别在于，所有线程必须同时达到栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。
- CyclicBarrier可以使一定数量的参与方反复地在栅栏位置汇集。这种算法通常将一个问题拆分一些列互相独立的子问题。如果所有线程都达到了栅栏位置，那么栅栏将打开，为此所有线程都被释放，而栅栏将被重置以便下次使用。

### Semaphore（信号量）
- 计数信号量用来控制同时访问的某个特定资源的操作数量，或者同时执行某个指定操作的数量。
- Semaphore中管理着一组虚拟许可，许可的初始量可通过构造函数来指定。在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。如果没有许可，那么acquire将阻塞直到有许可（或者直到被中断或者操作超时）。release方法将返回一个许可给信号量。

### Exchanger（交换机）
- 交换机是一个双方栅栏，每一个在栅栏处交换数据。
- 当双方执行的操作不对称的时候，Exchanger会很有用。当双方线程都到达栅栏的时候，将双方的数据进行交换，这个Exchanger对象可以使得两个线程生成的对象能够安全地交换。

## AQS
