# 数据结构复习笔记

## 数组
由相同类型的元素的集合所组成的数据结构，分配一块连续的内存来存储，利用元素的索引可以计算出该元素对应的存储地址。
1. 一维数组（向量）
1. 二维数组（矩阵）：行列数相等的矩阵称为方阵；元素大部分为零的矩阵称为稀疏矩阵；元素大部分非零的矩阵称为稠密矩阵。
1. 高维数组（张量）：存储方式有两种，从最左下标开始计数存储，和从最右下标开始计数存储。

## 顺序表
在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。

## 链
1. 单链表：链表的链接方向是单向的，对链表的访问要通过从头部开始，依序往下读取。
1. 双链表：每个数据结点中都有两个指针，分别指向直接后继和直接前驱。
1. 循环链表：最后一个结点指向头结点，形成一个环。
1. 块状链表：每一个块状链表的节点，也就是顺序表，可以被叫做一个块。
1. 异或链表：通过异或操作（这里用⊕表示）把前一个结点的地址和后一个结点的地址变成一个地址。
1. 跳表：底层是一个普通的有序链表。每个更高层都充当下面列表的“快速通道”，这里在第 i 层中的元素按某个固定的概率 p（通常为1/2或1/4）出现在第 i+1 层，每个元素平均出现在 1/（1-p）个列表中。

## 字符串
由零个或多个字符组成的有限序列。通常以串的整体作为操作对象。\
字符串的长度是在字符串中字符的数目，空串是长度为0的字符串。\
字符串串接是结合性的，但非交换性运算，空串充当单比特。\
字符串s被称为是字符串t的子串，如果存在（可能为空）字符串 u 和 v 使得 t = usv。

### 字符编码
* Unicode：使用 16 位的编码空间，也就是每个字符占用 2 个字节。理论上一共最多可以表示 2^16（即 65536）个字符。
  * UTF-8：一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容。
  * UTF-16：把Unicode字符集的抽象码位映射为16位长的整数的序列，用于数据存储或传递。
* ASCII：只能显示26个基本拉丁字母、阿拉伯数字和英式标点符号。
* GBK：字符有一字节和双字节编码，00–7F范围内是第一个字节，和ASCII保持一致。之后的双字节中，前一字节是双字节的第一位。总体上说第一字节的范围是81–FE，第二字节的一部分领域在40–7E，其他领域在80–FE。
* GB 18030：采用变长多字节编码，每个字可以由1个、2个或4个字节组成。编码空间庞大，最多可定义161万个字符。

## 散列表
根据键直接访问在内存存储位置的数据结构。通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录。

### 散列函数
* 直接定址法：取关键字或关键字的某个线性函数值为散列地址。例：hash（k）= k，hash（k）= a * k + b
* 数字分析法：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。
* 除留余数法：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址。例：hash（k）= k mod p，p <= m
* 平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。
* 折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为哈希地址。例：字符串取所有字符异或
* 随机数法

### 冲突处理
* 开放定址法：所有输入的元素全部存放在哈希表里。逐个（线性、平方或伪随机）探测存放地址的表，直到查找到一个空单元，把散列地址存放在该空单元。
* 拉链法：将散列到同一个存储位置的所有元素保存在一个链表中。
* 再散列：在上次散列计算发生冲突时，利用该次冲突的散列函数地址产生新的散列函数地址，直到冲突不再发生。

### 载荷因子
* 定义：α = 填入表中的元素个数 / 散列表的长度
* α 是散列表装满程度的标志因子，α 越大，表明填入表中的元素越多，产生冲突的可能性就越大；反之，α 越小，标明填入表中的元素越少，产生冲突的可能性就越小。

## 队列
先进先出的线性表，通常用链表或数组来实现。队列只允许在后端进行插入操作，在前端进行删除操作。
1. 单链队列：使用链表作为基本数据结构，所以不存在伪溢出的问题，队列长度也没有限制。
1. 循环队列：防止伪溢出的发生，但队列大小是固定的。
1. 阵列队列：使用数组作为基本数据结构，队列大小是固定的。

## 栈
后进先出的线性表，通常用链表或数组来实现。栈只允许在有序的线性数据集合的一端进行加入数据和移除数据的运算。
1. 数组堆栈：预先分配一个大小固定且较合适的数组空间。
1. 串列堆栈：以连结串列的形式完成。
* 基本操作：
  * 推入：将数据放入堆栈顶端，堆栈顶端移到新放入的数据。
  * 弹出：将堆栈顶端数据移除，堆栈顶端移到移除后的下一笔数据。

## 双端队列
一种具有队列和栈性质的抽象数据类型。双端队列中的元素可以从两端弹出，插入和删除操作限定在队列的两边进行。
* 基本操作：头部插入，尾部插入，头部删除，尾部删除，查看头部，查看尾部

## 树
具有树状结构性质的数据集合。\
每个节点都只有有限个子节点或无子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点；除了根节点外，每个子节点可以分为多个不相交的子树；树里面没有环路。

### 术语
* 节点的度：一个节点含有的子树的个数称为该节点的度；
* 树的度：一棵树中，最大的节点度称为树的度；
* 叶节点或终端节点：度为零的节点；
* 非终端节点或分支节点：度不为零的节点；
* 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
* 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
* 兄弟节点：具有相同父节点的节点互称为兄弟节点；
* 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
* 深度：对于任意节点 n ，n 的深度为从根到 n 的唯一路径长，根的深度为0；
* 高度：对于任意节点 n ，n 的高度为从 n 到一片树叶的最长路径长，所有树叶的高度为0；
* 堂兄弟节点：父节点在同一层的节点互为堂兄弟；
* 节点的祖先：从根到该节点所经分支上的所有节点；
* 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
* 森林：由 m（m >= 0）棵互不相交的树的集合称为森林；

### 二叉树
二叉树可以用数组或链接串列来存储。\
每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构，通常分支被称作左子树或右子树。\
二叉树的第 i 层至多拥有 2^(i-1) 个节点；深度为 k 的二叉树至多总共有 2^k - 1个节点。\
* 满二叉树：一棵深度为k，且有 2^(k+1) - 1个节点的二叉树，即每一层上的节点数都是最大节点数。\
* 完全二叉树：除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点。

#### 二叉搜索树
通常采取二叉链表作为二叉查找树的存储结构。
* 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值
* 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值
* 任意节点的左、右子树也分别为二叉查找树
* 没有键值相等的节点。

#### 笛卡尔树
通常由无相同元素的数列构造。
* 结点一一对应于数列元素。即数列中的每个元素都对应于树中某个唯一结点，树结点也对应于数列中的某个唯一元素。
* 中序遍历笛卡尔树即可得到原数列。即任意树结点的左子树结点所对应的数列元素下标比该结点所对应元素的下标小，右子树结点所对应数列元素下标比该结点所对应元素下标大。
* 树结构存在堆序性质，即任意树结点所对应数值大／小于其左、右子树内任意结点对应数值。

### 平衡树
几乎所有平衡树的操作都基于树旋转操作，通过旋转操作可以使得树趋于平衡。

#### AVL树
任一节点对应的两棵子树的最大高度差为1。\
节点的平衡因子是它的左子树的高度减去它的右子树的高度。带有平衡因子1、0或-1的节点被认为是平衡的。带有平衡因子-2或2的节点被认为是不平衡的。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。
* 左左情况：右旋。
* 右右情况：左旋。
* 左右情况：先左旋，再右旋。
* 右左情况：先右旋，再左旋。

#### 红黑树
红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。红黑树也是2-3-4树的一种等同。\
节点是红色或黑色；根是黑色；所有叶子都是黑色；每个红色节点必须有两个黑色的子节点；从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。\
红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。\
需考虑7种情况来维护红黑树的平衡。

#### AA树
红黑树的一种变种。\
红节点只能为右节点；所有叶节点的高度都是1；每个左孩子的高度恰好为其父亲的高度减一；每个右孩子的高度等于其父亲的高度或为其父亲的高度减一；每个右孙子的高度严格小于其祖父节点的高度；每一个高度大于1的节点有两个子节点。\
只需考虑2种情形来维护AA树的平衡。

#### 树堆
有一个随机附加域满足堆的性质的二叉搜索树。\
左子树和右子树也分别是一个树堆，和一般的二叉搜索树不同的是，树堆记录一个额外的数据，就是优先级。\
仅需要两种旋转即可维护堆性质。

#### 伸展树
在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法，在每次查找之后对树进行调整，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。\
平均效率不输于其他平衡树，不需要记录用于平衡树的冗余信息，但它有可能会变成一条链，例如，在以非递减顺序访问全部n个之后就会出现这种情况。

#### 替罪羊树
一种基于部分重建的自平衡二叉搜索树。

### B树
一种自平衡的树，能够保持数据有序。Ｂ树通过约束所有叶子节点在相同深度来保持平衡。适用于读写相对大的数据块的存储系统，例如磁盘。\
内部（非叶子）节点可以拥有可变数量的子节点，当数据被插入或从一个节点中移除，它的子节点数量发生变化。为了维持在预先设定的数量范围内，内部节点可能会被合并或者分离。\
B树中每一个内部节点会包含一定数量的键，键将节点的子树分开。\
B树不需要像其他自平衡查找树那样频繁地重新保持平衡，但是由于节点没有被完全填充，可能浪费了一些空间。B树通过保证内部节点至少半满来最小化空间浪费。

#### B+树
通常被表示为一组有序的元素和子指针。对于所有内部节点，子指针的数目总是与元素的数目相同。所有叶子都在相同的高度上，叶结点本身按关键字大小从小到大链接。\
键值的拷贝被存储在内部节点；键值和记录存储在叶子节点；另外，一个叶子节点可以包含一个指针，指向另一个叶子节点以加速顺序存取。

#### 2-3树
内部节点（存在子节点的节点）要么有2个孩子和1个数据元素，要么有3个孩子和2个数据元素，叶子节点没有孩子，并且有1个或2个数据元素。

#### 2-3-4树
2-节点包含1个元素和2个儿子，3-节点包含2个元素和3个儿子，4-节点包含3个元素和4个儿子。

## 堆

## 优先队列

## 并查集

## 图
